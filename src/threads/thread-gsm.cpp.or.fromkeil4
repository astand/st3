#include "thread-gsm.h"
#include "configs/free-rtos-def.h"

#include "Configs/MainConfig.h"
#include "Configs/Version.h"
#include "Timers.h"
#include "commontaskfuncs.h"
#include "AtCommandSet.h"
#include "magic/magic.h"
#include "gsmprot.h"
#include "Stm32_hal_drv.h"
#include "generalsett.h"
#include "agps.h"
#include "Abstract/ISectorWriter.hpp"

#include "nmeautil/nmeautil.hpp"
#include "TrekLocationDescriptor.h"

#include "BoardSide.h"
#include "Factory/McuFlashFactory.hpp"

using namespace MAGIC;
using namespace ATFORSIM900;


/* ------------------------------------------------------------------------- *
 *    Prototypes of static functions
 * ------------------------------------------------------------------------- */
uint8_t GSM_Send_SMS(uint8_t* NumberPtr, uint8_t Len, uint8_t Options);
int32_t GsmGetAck (uint16_t rx_to, const char* cmp_s, const char* alt_s);
int32_t JConfSocketUpdate();
uint8_t m66_CheckFailAnswer(char* buf, int32_t len);
/* -------------- +++++++++++++++++++++++++++++++++++++++ ------------------ */
void osDelay(uint16_t tim);

/* ------------------------------------------------------------------------- *
 * 	       -----------------Defines sector -----------------
 * ------------------------------------------------------------------------- */
#define GSM_SMS_REPLY_NEED				0x01
#define GSM_SMS_LONG_VALID				0x02
/* ------------------------------------------------------------------------- */
#define GSM_SMS_FORMAT_MASK			  0x30
#define GSM_SMS_FORMAT_7BIT			  0x00
#define GSM_SMS_FORMAT_16BIT			0x10
#define GSM_SMS_FORMAT_HEX				0x20
#define GSM_SMS_FORMAT_BINARY		  0x30

/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */
#define NET_RESTART_TO		        60000
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

PortHal en4v = PortHal(GPIOC, 13, true);
PortHal pwk = PortHal(GPIOC, 14, true);
PortHal dcd = PortHal(GPIOC, 1, true);

static bool dcd_state = true;


static GeneralSett memconf = GeneralSett();
static const TcpInstance_c defgprs = TcpInstance_c();
static TcpInstance_c* currgprs = 0;


static char serv_ip[20];
static char serv_prt[10];
char* ssrv[2] = {serv_ip, serv_prt};
/* ------------------------------------------------------------------------- *
 *  Serial control Settings
 * ------------------------------------------------------------------------- */
#define SERIAL_PORT         USART2
#define SerialHandler       USART2_IRQHandler
/* ------------------------------------------------------------------------- */
gsic gsm0(SERIAL_PORT, 2048, osDelay);


ISectorWriter* firmsaver = FlashFactory::GetSectorWriter();

/* ------------------------------------------------------------------------- */
typedef struct
{
  uint8_t y;
  uint8_t m;
  uint8_t d;
  uint8_t hh;
  uint8_t mm;
  uint8_t ss;
  uint8_t valid;
} DATETIMEFORMAT;
DATETIMEFORMAT dateTime;



/* ------------------------------------------------------------------------- */
const uint8_t daytab [2][13] =
{
  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

uint8_t GSM_TX_Buff[1024];
uint8_t GSM_RX_Buff[1024];

BoardSideInst bsin;

uint8_t smsoptions;

uint32_t time_register_wait = 0;
/* ------------------------------------------------------------------------- */
uint8_t GSM_SMS_PDU[256];
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */
static volatile enum
{
  eG_Start,
  eG_Init,
  eG_Idle,
  eG_TryConnect,
  eG_ConnIdle,
  eG_Disconnect,
  eG_HardDie,
  eG_Wait
}
g_GsmMainState;
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */
uint8_t Inc_Phone_In[MAX_PHONE_LEN + 1];

typedef struct
{
  uint32_t offset;
  uint32_t len;
  void ClrBlk(void)
  {
    offset = len = 0;
  }
} sMemManager_t;

sMemManager_t prdat;

/* ------------------------------------------------------------------------ */
struct
{
  bool res;
  bool load;
  bool accept;
} firm_inst = {false, false, false};

/* ------------------------------------------------------------------------- */
enum
{
  /* red */
  eLedIdle = 0,
  eLedNoSim = 1,
  eledNoEcho = 2,
  /* grn */
  eLedReg = 3,
  eLedNoReg = 4,
  eLedConn = 5,
  eledOff = 6,

  eLedSize
} eLedState = eledOff;
/* ------------------------------------------------------------------------- */
static uint32_t led_templates[eLedSize] =
{
  0xFFFFFFFF,
  /* no sim   : -----------+-+ */
  0x00000088,
  /* no echo  : ------++-++-++*/
  0x00000888,
  /* reg      : ---------+++++ */
  0x00000FFF,
  /* no reg   : -------------+ */
  0x00000001,
  /* connect  : -+-+-+-+-+-+-+ */
  0xCCCCCCCC,
  /* off */
  0
};
/* ------------------------------------------------------------------------- */
//62.141.87.178,20011
//178.140.6.233,20201
const char* gpr_debug_str = "GPRS 000,,,,,,178.140.204.50,20201,,,240,2,3,24";
//const char * gpr_debug_str = "GPRS 000,,,,,,62.141.87.178,20012,,,240,2,3,24";

#define INFO_STRING_MASK "IMEI=%s,VERSION=%d.%d.%d,NAME=%s"

char testinfostring[64];
static char imei_str[32] = "111110002220000";
/* ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- *
 *  Hardware GSM Serial bytes reciever/transmitter STM32 115200
 * ------------------------------------------------------------------------- */
extern "C" void SerialHandler (void)
{
  gsm0.Handler();
}


/* Load session_to with 10s * val ------------------------------------------ */
void TOSession(uint32_t val)
{
  LoadSecTim(sessgsm_to, val * 10);
}
/* Get  session_to == 0 ? -------------------------------------------------- */
uint32_t TOSession()
{
  return (GetTim(sessgsm_to));
}


void TOSilence(uint32_t val)
{
  LoadSecTim(failgsm_to , val * 10);
}
uint32_t TOSilence()
{
  return GetTim(failgsm_to);
}




void TOCommon(uint32_t val)
{
  LoadTim(incgsm_to, val);
}
bool TOCommon()
{
  return (GetTim(incgsm_to) == 0) ? (false) : (true);
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
void GSM_Switch_Off(void)
{
  return;
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
void GsmSwitchOn(void)
{
  en4v.Off();
  os_dly_wait(2000);
  en4v.On();
  pwk.Off();
  os_dly_wait(1000);
  pwk.On();
  os_dly_wait(3000);
  return;
}




/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint8_t m66_CheckFailAnswer(char* buf, int32_t len)
{
  if (memcmp(buf, "NO DIALTONE", len) == 0 ||
      memcmp(buf, "ERROR", len) == 0 ||
      memcmp(buf, "NO CARRIER", len) == 0 ||
      memcmp(buf, "+CMS ERROR", 10) == 0)
    return (1);

  return (0);
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint8_t m66BreakSession()
{
  /* Switch to command mode by sending '+++' with silence 1 sec before,
   * end 0.5 sec after */
  os_dly_wait(50);
  DBG_Gsm("< + + + >");
  gsm0.StrCmd("+++");
  GsmGetAck(1000, AT_COMMAND_OK_ACK, 0);
  os_dly_wait(50);
  return (0);
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint32_t GsmReceiveSMS(uint8_t* ulPhoneNum)
{
#define PDU_TYPE_VALUE        	\
  (GSM_SMS_PDU[PDU_TYPE_OFFSET + (GSM_SMS_PDU[0])])
#define PDU_OA_LEN_VALUE      	\
  (GSM_SMS_PDU[PDU_OA_LEN_OFFSET + (GSM_SMS_PDU[0])])
#define PDU_OA_TYPE_VALUE     	\
  (GSM_SMS_PDU[PDU_OA_TYPE_OFFSET + (GSM_SMS_PDU[0])])
#define PDU_OA_DATA_VALUE(x)    \
  (GSM_SMS_PDU[(x) + PDU_OA_DATA_OFFSET + (GSM_SMS_PDU[0])])
#define PDU_OA_LEN_EVEN_VALUE		\
  (PDU_OA_LEN_VALUE + (PDU_OA_LEN_VALUE % 2))
#define PDU_DCS_VALUE           \
  (GSM_SMS_PDU[(GSM_SMS_PDU[0]) + \
               (PDU_OA_LEN_EVEN_VALUE >> 1) + PDU_DCS_OFFSET])
#define PDU_UDL_VALUE				    \
  (GSM_SMS_PDU[(GSM_SMS_PDU[0]) + \
               (PDU_OA_LEN_EVEN_VALUE >> 1) + PDU_UDL_OFFSET])
#define PDU_DATA_POINTER			  \
  (&GSM_SMS_PDU[(GSM_SMS_PDU[0]) + \
                (PDU_OA_LEN_EVEN_VALUE >> 1) + PDU_DATA_OFFSET])
  uint8_t c;
  uint8_t Cntr, CRChi, CRClo;
  uint8_t* PDUPtr;
  const char* p;
  uint8_t HiLoHex;
  int i = 0;
  int32_t msgid, pdulen;
  uint32_t smsretval = 0;
  smsoptions = 0;
  /* request availible SMS */
  os_dly_wait(10);
  DBG_Gsm("[at]:sms list: ");
  gsm0.StrCmd(atcmd::SMS_GET);

  if (GsmGetAck(2 * TIMER_FREQ, AT_SMS_GET_ANSWER,
                AT_COMMAND_OK_ACK) <= 0)
    /*if no any SMS goto no_sms_state */
    goto _No_SMS;

  msgid = str0::Atoi(str0::ToSym(gsm0.Str(), ' ', 1));
  pdulen = str0::Atoi(str0::ToSym(gsm0.Str(), 3));
  GsmGetAck(1 * TIMER_FREQ, 0, 0);
  p = gsm0.Str();

  //  p = (str0::ToSym(gsm0.Str(), 3) + 5);
  /* Take hex data from ASCII hex format */
  while (i < PROT_MAX_SIZE)
  {
    c = p[i];

    if (c >= '0' && c <= '9')
      c -= '0';
    else if (c >= 'A' && c <= 'F')
      c = c - 'A' + 0x0A;
    else if (c == '\0')
      break;

    if (!(i % 2))
      GSM_SMS_PDU[i >> 1] = c << 4;
    else
      GSM_SMS_PDU[i >> 1] |= c;

    i++;
  }

//	std::sprintf(cTempBuf, AT_DELETE_ALL_MESSAGE, msgid);

  /* Check valid parse functions */
  if ((i >> 1) != (1 + (GSM_SMS_PDU[0]) + pdulen))
    /* if common len (i/2) non equal summ scanning values -> error */
    goto _Bad_SMS;

  /* check SMS-DELIVER status byte xxxxxx00b must be */
  if ((PDU_TYPE_VALUE & 0x03) != 0x00)
    goto _Bad_SMS;

  DBG_Gsm("[at]:del sms> ");
  os_dly_wait(100);
  gsm0.SmsDel(msgid);
  GsmGetAck(1 * TIMER_FREQ, AT_COMMAND_OK_ACK, 0);
  /* Get type of adress value */
  c = PDU_OA_TYPE_VALUE; // type-of-address
  c &= 0x70;

  /* if international bit set '+' add to phone */
  if (c == 0x10)
    *ulPhoneNum++ = '+';

  if (c < 0x50 || PDU_OA_LEN_VALUE < MAX_PHONE_LEN)
  {
    /* all OK it can store phone number \PDU_OA_LEN_EVEN_VALUE
     * macros make PDU_OA_LEN_VALUE even value */
    for (i = 0; i < PDU_OA_LEN_EVEN_VALUE; i += 2)
    {
      c = (PDU_OA_DATA_VALUE(i >> 1));

      if ((c & 0x0F) < 10)
        *ulPhoneNum++ = (c & 0x0f) + '0';

      if (((c >> 4) & 0x0F) < 10)
        *ulPhoneNum++ = (c >> 4 & 0x0F) + '0';
    }

    *ulPhoneNum++ = 0x00;
  }

  c = PDU_DCS_VALUE;
  i = PDU_UDL_VALUE;
  DBG_2Gsm("[sms]Info Num:<%s>\n",
           (char*)(ulPhoneNum - PDU_OA_LEN_EVEN_VALUE - 3));
  PDUPtr = PDU_DATA_POINTER;

  switch (c & 0xEC)
  {
    case 0x00:

      /* 7-bit text */
      if (i < 2) break;

      pdulen = i;
      Cntr = 0;
      HiLoHex = 1;

      for (i = 0; i != pdulen; i++)
      {
        c = (PDUPtr[i - (i >> 3) - 1] >> (8 - (i & 0x07))) | (PDUPtr[i - (i >> 3)] <<
            (i & 0x07));
        c &= 0x7F;

        if (c >= '0' && c <= '9') c -= '0';
        else if (c >= 'A' && c <= 'F') c = c - 'A' + 0x0A;
        else if (c >= 'a' && c <= 'f') c = c - 'a' + 0x0A;
        else if ((c == ' ' || c == '.' || c == ',' || c == ';' || c == ':') &&
                 HiLoHex == 1)
          continue;
        else goto _Verbal_7bit;

        if (HiLoHex == 1)
        {
          GSM_RX_Buff[Cntr] = c << 4;
          HiLoHex = 0;
        }
        else
        {
          GSM_RX_Buff[Cntr] |= c;
          Cntr++;
          HiLoHex = 1;
        }
      }

      if (Cntr < 4 || HiLoHex == 0)
        break;

      smsoptions = GSM_SMS_FORMAT_HEX;
      smsretval = Cntr;
      break;
_Verbal_7bit:

      for (i = 0; i != pdulen; i++)
      {
        c = (PDUPtr[i - (i >> 3) - 1] >> (8 - (i & 0x07))) | (PDUPtr[i - (i >> 3)] <<
            (i & 0x07));
        c &= 0x7F;

        if (c >= 'a' && c <= 'z') c &= 0xDF;

        GSM_RX_Buff[i] = c;
      }

      GSM_RX_Buff[pdulen] = 0x00;
      smsoptions = GSM_SMS_FORMAT_7BIT;
      smsretval = pdulen;
      break;

    case 0x04:

      // 8-bit data
      if (i < 6)
        break;

      pdulen = i;
      cppCrc16::crc16InitValue(CRChi, CRClo);

      for (i = 0; i != pdulen; i++)
      {
        c = *PDUPtr++;
        GSM_RX_Buff[i] = c;
        cppCrc16::crc16UpdateValue(CRChi, CRClo, c);
      }

      if (CRClo != 0 || CRChi != 0)
        break;

      smsoptions = GSM_SMS_FORMAT_BINARY;
      smsretval = pdulen - 2;
      break;

    case 0x08:

      // 16-bit verbal text
      if (i < 4)
        break;

      pdulen = i >> 1;

      for (i = 0; i != pdulen; i++)
      {
        c = PDUPtr[1];

        if ((PDUPtr[0]) != 0x00)
        {
          // russian upcase
          if (c >= 0x10 && c <= 0x4F) c = (c + 0xB0) & 0xDF;
        }
        else
        {
          // english upcase
          if (c >= 'a' && c <= 'z') c &= 0xDF;
        }

        GSM_RX_Buff[i] = c;
        PDUPtr += 2;
      }

      GSM_RX_Buff[pdulen] = 0x00;
      smsoptions = GSM_SMS_FORMAT_16BIT;
      smsretval = pdulen;
      break;

    default:
      break;
  }

_No_SMS:
  os_dly_wait(10);
  return (smsretval);
_Bad_SMS:
  // delete all SMS
  os_dly_wait(1000);
  DBG_Gsm("AT Del SMS: %d", msgid);
  gsm0.SmsDel(msgid);
  GsmGetAck(3 * TIMER_FREQ, AT_COMMAND_OK_ACK, 0);
  return (smsretval);
}

/* ------------------------------------------------------------------------- *
 *  use to check correct command answer
 *  \usRxTimeout time for wait correct answer (1000 * sec)
 *  \cmpString string correct answer
 *
 *  /return 1 if compare strings OK, 0 if not ok,
 *  MUST return 0xFF if no any answer future....
 * ------------------------------------------------------------------------- */
int32_t GsmGetAck (uint16_t rx_to, const char* cmp_s, const char* alt_s)
{
  uint32_t ulCntIndx = 0;
  uint32_t ulAnyCorrectAnswerIndx = 0;
  LoadTim(fastgsm_to, rx_to);
  const char* prxstr = gsm0.Str();

//  gsic::strbuf_t* prxstr = (gsic::strbuf_t*)gsm0.Str();
  while (GetTim(fastgsm_to))
  {
    os_tsk_pass();

    /* GsmReceiveString() return number of received bytes in correct answer */
    if ((ulCntIndx = gsm0.ReceiveStr()) != 0)
    {
      /* remember that some correct answer was received */
      ulAnyCorrectAnswerIndx = ulCntIndx;
      DBG_Gsm((char*)prxstr);

      if (cmp_s == 0)
      {
        DBG_Gsm("\t\tslip<%s>\n", prxstr);
        /* if pointer to compare string == 0 slip full next string
         * and return lenght*/
        return ulCntIndx;
      }

      if (alt_s != 0)
      {
        /* check compare */
        if (memcmp(prxstr, alt_s, strlen(alt_s)) == 0)
        {
          DBG_Gsm("\t\talt<%s>\n", prxstr);
          return 0;
        }
      }

      if (memcmp (prxstr, cmp_s, strlen(cmp_s)) == 0)
      {
        DBG_Gsm("\t\tcmp<%s>\n", cmp_s);
        /* if OK return len of string */
        return ulCntIndx;
      }

      if (m66_CheckFailAnswer((char*)prxstr, ulCntIndx) == 1)
      {
        DBG_Gsm("\t\tBAD<%s>\n" , prxstr);
        /* if ERROR string return 0 */
        return 0;
      }
    }
  } // time out GSM_Timer => no any waiting string string

  if (ulAnyCorrectAnswerIndx > 0)
  {
    /* was received some not waiting and not error string */
    DBG_Gsm("\t\twait<%s>: get<%s>\n", cmp_s , prxstr);
    return 0;
  }
  else
    /* if here => no any string from modem  */
    DBG_Gsm("\t\tERROR NO ANSW\n"/*,  noAnswerCounter*/);

  return -1;
}
/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint32_t GetStringToComma(char* inMsg, char* outMsg)
{
  uint8_t i;

  for (i = 0; i < 32; i++)
  {
    /* try find comma in string */
    if (inMsg[i] == ',')
    {
      /* has been found succsess add terminate and return */
      outMsg[i++] = '\0';
      break;
    }
    else
      outMsg[i] = inMsg[i];
  }

  return i;
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
//uint32_t GetTimeParam(uint32_t ulParamPosition)
//{
//	/* \ulVal  value for number desiring position */
//	uint32_t ulVal = 4;
//	/*  Try sscanf value in string that begin from \ulParamPosition 's comma
//	 * if sscanf succes then we can return correct value (mul 10)
//	 * else will be return default value (40 s) */
//	sscanf(GsmPassComma(gprs_str, ulParamPosition), "%d", &ulVal);
//	return (ulVal * 10);
//}


/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
void GSM_Send_Decimal(uint8_t Byte)
{
  if (Byte >= 100)
  {
    gsm0.Send((Byte / 100) + '0');
    Byte = Byte % 100;
  }

  gsm0.Send((Byte / 10) + '0');
  Byte = Byte % 10;
  gsm0.Send(Byte + '0');
  return;
}


/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint8_t* GSM_Save_Byte_As_Hex(uint8_t* DstPtr, uint8_t Byte)
{
  if (Byte >= 0xA0) *DstPtr++ = (((Byte - 0xA0) & 0xF0) >> 4) + 'A';
  else *DstPtr++ = ((Byte & 0xF0) >> 4) + '0';

  Byte &= 0x0F;

  if (Byte >= 0x0A) *DstPtr++ = (Byte - 0x0A) + 'A';
  else *DstPtr++ = Byte + '0';

  return (DstPtr);
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint8_t GSM_Send_SMS(uint8_t* NumberPtr, uint8_t Len, uint8_t Options)
{
  uint8_t i, c, ShiftCntr, CRChi, CRClo;
  uint8_t* PDUPtr;
  uint8_t TmpChars[2];
  /* prepare PDU */
  GSM_SMS_PDU[0] = 0x00;
  /* first octet SMS-SUBMIT */
  GSM_SMS_PDU[1] = 0x11;
  GSM_SMS_PDU[2] = 0x00;

  /* telephone number */
  if (NumberPtr[0] == 0x00) return (0);
  else if (NumberPtr[0] == '+') GSM_SMS_PDU[4] = 0x91;
  else GSM_SMS_PDU[4] = 0x81;

  i = 0;

  while (i < 32)
  {
    c = *NumberPtr++;

    if (c == 0x00) break;

    if (c < '0' || c > '9') continue;

    if ((i & 1) == 0) GSM_SMS_PDU[5 + (i >> 1)] = (c - '0') | 0xF0;
    else GSM_SMS_PDU[5 + (i >> 1)] &= ((c - '0') << 4) | 0x0F;

    i++;
  }

  GSM_SMS_PDU[3] = i;
  PDUPtr = &(GSM_SMS_PDU[5 + ((i + 1) >> 1)]);
  /* TP-PID */
  *PDUPtr++ = 0x00;

  if (Options & GSM_SMS_LONG_VALID) c = 196; // 30 days
  else c = 11; // 1 hour

  switch (Options & GSM_SMS_FORMAT_MASK)
  {
    case GSM_SMS_FORMAT_7BIT:
      // 7-bit verbal text
      // TP-DCS
      *PDUPtr++ = 0x00;
      // TP-VP
      *PDUPtr++ = c;

      // TP-User-Data-Length
      if (Len > 160) Len = 160;

      *PDUPtr++ = Len;
      c = 0x00;
      ShiftCntr = 0;

      for (i = 0; i != Len; i++)
      {
        TmpChars[0] = (GSM_TX_Buff[i]) & 0x7F;
        c |= (TmpChars[0]) << ShiftCntr;
        ShiftCntr += 7;

        if (ShiftCntr >= 8)
        {
          *PDUPtr++ = c;
          ShiftCntr -= 8;
          c = (TmpChars[0]) >> (7 - ShiftCntr);
        }
      }

      if (ShiftCntr != 0) *PDUPtr++ = c;

      break;

    case GSM_SMS_FORMAT_16BIT:
      // 16-bit verbal text
      // TP-DCS
      *PDUPtr++ = 0x08;
      // TP-VP
      *PDUPtr++ = c;

      // TP-User-Data-Length
      if (Len > 70) Len = 70;

      *PDUPtr++ = Len << 1;

      for (i = 0; i != Len; i++)
      {
        c = GSM_TX_Buff[i];

        if (c >= 0xC0)
        {
          PDUPtr[0] = 0x04;
          PDUPtr[1] = c - 0xB0;
        }
        else
        {
          PDUPtr[0] = 0x00;
          PDUPtr[1] = c;
        }

        PDUPtr += 2;
      }

      break;

    case GSM_SMS_FORMAT_HEX:
      // 7-bit hex text
      // TP-DCS
      *PDUPtr++ = 0x00;
      // TP-VP
      *PDUPtr++ = c;

      // TP-User-Data-Length
      if (Len > 80) Len = 80;

      *PDUPtr++ = Len << 1;
      c = 0x00;
      ShiftCntr = 0;

      for (i = 0; i != Len; i++)
      {
        GSM_Save_Byte_As_Hex(TmpChars, GSM_TX_Buff[i]);
        // hi hex char
        c |= (TmpChars[0]) << ShiftCntr;
        ShiftCntr += 7;

        if (ShiftCntr >= 8)
        {
          *PDUPtr++ = c;
          ShiftCntr -= 8;
          c = (TmpChars[0]) >> (7 - ShiftCntr);
        }

        // lo hex char
        c |= (TmpChars[1]) << ShiftCntr;
        ShiftCntr += 7;

        if (ShiftCntr >= 8)
        {
          *PDUPtr++ = c;
          ShiftCntr -= 8;
          c = (TmpChars[1]) >> (7 - ShiftCntr);
        }
      }

      if (ShiftCntr != 0) *PDUPtr++ = c;

      break;

    case GSM_SMS_FORMAT_BINARY:
      // 8-bit data
      // TP-DCS
      *PDUPtr++ = 0x04;
      // TP-VP
      *PDUPtr++ = c;

      // TP-User-Data-Length
      if (Len > 138) Len = 138;

      *PDUPtr++ = Len + 2;
      cppCrc16::crc16InitValue(CRChi, CRClo);

      for (i = 0; i != Len; i++)
      {
        c = GSM_TX_Buff[i];
        *PDUPtr++ = c;
        cppCrc16::crc16UpdateValue(CRChi, CRClo, c);
      }

      *PDUPtr++ = CRClo;
      *PDUPtr++ = CRChi;
      break;
  }

  // send
  gsm0.StrCmd("\r\n");
  os_dly_wait(100);
  i = (uint8_t)(PDUPtr - GSM_SMS_PDU);
  DBG_Gsm("[at]:send sms> ");
  gsm0.StrCmd("AT+CMGS=");
  GSM_Send_Decimal(i - 1);
  gsm0.Send('\r');
// 	GSM_Wait_TX_Complete(1*TIMER_FREQ);
  os_dly_wait(10);
  PDUPtr = GSM_SMS_PDU;

  for (; i != 0; i--)
  {
    GSM_Save_Byte_As_Hex(TmpChars, *PDUPtr++);
    gsm0.Send(TmpChars[0]);
    gsm0.Send(TmpChars[1]);
  }

// 	GSM_Wait_TX_Complete(1*TIMER_FREQ);
  gsm0.Flush();
  gsm0.Send(0x1A); // ctrl-Z
  // long timeout - sending SMS may be take much time
  GsmGetAck(10 * TIMER_FREQ, AT_COMMAND_OK_ACK, 0);
  os_dly_wait(50);
  return (1);
}


/* ------------------------------------------------------------------------- *
 * led indicate task
 * call from special <tskledBlinkThread> 100 ms task in main.c
 * ------------------------------------------------------------------------- */
uint32_t LedBlinkGsm(void)
{
  uint32_t mmask;
  led_templates[eLedState] = __ror(led_templates[eLedState], 1);
  mmask = ((led_templates[eLedState]) & 1) ? (1) : (0);
  return mmask;
}
/* ------------------------------------------------------------------------- *
 * function for clock tick
 * call from <led task>
 * ------------------------------------------------------------------------- */
//int8_t dateTimeTick (void)
//{
//	static uint32_t dateTimePrescaler = 0;
//	uint8_t leapyear;

//	/* first check time valid if flags == 0 then return */
//	if (!(dateTime.valid))
//		return -2;

//	if (++dateTimePrescaler < 10)
//		/* prescaler 10 - tick every 100ms*/
//		return -1;

//	dateTimePrescaler = 0;

//	/* start time increment */
//	if (++dateTime.ss < 60)
//		return 0;

//	dateTime.ss = 0;

//	if (++dateTime.mm < 60)
//		return 1;

//	dateTime.mm = 0;

//	if (++dateTime.hh < 24)
//		return 2;

//	dateTime.hh = 0;
//	/* leap year */
//	leapyear = ((dateTime.y + 2000) % 4 == 0 &&
//	            (dateTime.y + 2000) % 100 != 0 ||
//	            (dateTime.y + 2000) % 400 == 0);

//	if (++dateTime.d <= daytab[leapyear][dateTime.m])
//		return 3;

//	/* day number greater then etalon -> set 1 number and increment mounth */
//	dateTime.d = 1;

//	if (++dateTime.m < 13)
//		return 4;

//	dateTime.m = 1;
//	dateTime.y++;
//	return 5;
//}


/* ------------------------------------------------------------------------ *
 * function for getting day index of year
 * ------------------------------------------------------------------------ */
uint32_t getYearDayIndx (const DATETIMEFORMAT dayIndxDate)
{
//   uint8_t leapyear;
  uint8_t indx;
  uint32_t res = 0;

  for (indx = 1; indx < dayIndxDate.m; res += daytab[1][indx++]);

  return res += dayIndxDate.d;
}


/* ------------------------------------------------------------------------- *
 *  function for getting day of week
 * ------------------------------------------------------------------------- */
uint32_t getDayOfWeek(const DATETIMEFORMAT lcl_DateTime)
{
  int32_t a = (14 - (lcl_DateTime.m)) / 12;
  int32_t y = (lcl_DateTime.y) - a;
  int32_t m = ((lcl_DateTime.m) + 12 * a - 2);
  return ((7000 - 1 +
           (lcl_DateTime.d + y + (y / 4) - (y / 100) + (y / 400) + (31 * m) / 12)) % 7);
}

/* ------------------------------------------------------------------------- *
 * Func for convert dateTime to -12 hours
 * for getting day (12:00) date tick
 * ------------------------------------------------------------------------- */

DATETIMEFORMAT MagicDateTimeConverter(DATETIMEFORMAT lDatTim)
{
  uint8_t leapyear;

  if (lDatTim.hh < 12)
  {
    /* prev day */
    if (lDatTim.d == 1)
    {
      if (lDatTim.m == 1)
      {
        /* roll back  month and year*/
        lDatTim.m = 13;
        lDatTim.y--;
      }

      leapyear = ((lDatTim.y + 2000) % 4 == 0 &&
                  (lDatTim.y + 2000) % 100 != 0 ||
                  (lDatTim.y + 2000) % 400 == 0);
      lDatTim.m--;
      lDatTim.d = daytab[leapyear][lDatTim.m];
    }
    else
      (lDatTim.d)--;
  }

  return lDatTim;
}

/* ------------------------------------------------------------------------- *
 * get actual time for another EVENT
 * format this param - (h*60 + m)
 * ------------------------------------------------------------------------- */
uint32_t GetActualTime (uint8_t* shedBuff, uint32_t onT, uint32_t offT)
{
  int32_t   offsetTable;
  uint32_t  resTime;

  if ((shedBuff[2] & 0xF0) == 0xF0)
  {
    /* time from table */
    if ((offsetTable = (int8_t)(shedBuff[3])) < 0)
      /* negative offset */
      offsetTable = (1440 + offsetTable);

    if (shedBuff[2] & 1)
    {
      /* ontable */
      resTime = ((onT + offsetTable) % 1440);
    }
    else
    {
      /*off table */
      resTime = ((offT + offsetTable) % 1440);
    }
  }
  else
  {
    /* actual time from shed event */
    resTime = (shedBuff[2] * 60) + (shedBuff[3]);
  }

  return resTime;
}

/* ------------------------------------------------------------------------- *
 * function for getting actual state of light system mode
 * call in <GsmThreadTickTask> every one minute
 * ------------------------------------------------------------------------- */
//void GsmThreadTickTask(void)
//{
//	if (dateTimeTick() > 0)
//	{
//		/* minute change */
//		DBG_Common("[clock]<%d><%d><%d>-<%d><%d><%d>\n",
//		           dateTime.hh, dateTime.mm, dateTime.ss,
//		           dateTime.d, dateTime.m, dateTime.y);
////		SheduleLightModeState(dateTime);
//	}
//}



/* ------------------------------------------------------------------------- *

 * ------------------------------------------------------------------------- */
int32_t GTftpSend(uint16_t len)
{
  int32_t blksize = 0;

  if (bsin.SendActionDenied())
    /* fid == 0 or fid are DATA_OUT flag */
    return 0;

  if (bsin.bchief.IsBlockSendPermitted())
  {
    bsin.headDataUp();
    LoadTim(tftp_resend_to, 15000);
  }
  else
  {
    if (GetTim(tftp_resend_to) == 0)
    {
      if (!bsin.bchief.RollBackBidsend())
      {
        DBG_2Gsm("ftp-> Resend count fail. Stop sending\n");
        bsin.ResetAll();
      }
    }

    return 0;
  }

  while (!gsm0.SendAvail(800))
    os_tsk_pass();

  switch (bsin.getFid())
  {
    case (ID_GET_FILENOTES):
      blksize = (FileLink())->UploadList((bsin.bchief.bidsend - 1) * 25, 25,
                                         bsin.from->msg);
      break;

    case (ID_GET_TRACK):
      blksize = (FileLink())->UploadTrek(bsin.NeedTreck(), (bsin.bchief.bidsend - 1) * 25,
                                         (25 * NaviNote::Lenght()),
                                         bsin.from->msg);
//      blksize = FileTrackUpload(bsin.from->msg,
//                                (bsin.bchief.bidsend - 1) * mxmap::count_block,
//                                mxmap::occur_block, bsin.NeedTreck());
//      blksize *= navinote::Lenght();
      break;

    case (ID_GET_INFO):
//			sprintf((char*)bsin.from->msg,INFO_STRING_MASK,imei_str, memconf.ID);
      /* ??? need move filling info string to other function */
      strcpy((char*)bsin.from->msg, testinfostring);
      blksize = strlen((char*)bsin.from->msg) + 1;

      if (bsin.bchief.bidsend != 1)
        blksize = 0;

      break;

    case (ID_GET_ECHO):
    default:
      bsin.ResetAll();
      break;
  } // switch

  if (blksize < 0)
  {
    /* error */
    bsin.ResetAll();
    bsin.headError((uint16_t)blksize);
    blksize = 0;
  }

  DBG_2Gsm("ftp-> OPC:%04x. ID:%04x. Size:%d\n", bsin.from->opc,
           bsin.from->blockid, blksize);
  bsin.bchief.FixLastBid(blksize);
  gsm0.SendBin((uint8_t*)(bsin.from), blksize + 4);
  return 0;
}


/* ------------------------------------------------------------------------- *

 * ------------------------------------------------------------------------- */
int32_t GTftpACKParse(uint16_t len)
{
  LoadTim(tftp_resend_to, 15000);
  bsin.Validation();

  if (bsin.bchief.Last())
    bsin.ResetAll();

  return 0;
}

/* ------------------------------------------------------------------------- *

 * ------------------------------------------------------------------------- */
int32_t GTftpDATAParse(int32_t len)
{
  /* not correct block ID */
  if (!bsin.Validation())
    return 0;

  /* ??? need check timer for correct exit from Fid() state */
  len -= 4;
  bsin.headAckUp();
  bsin.FInsize.AddPassing((int32_t)len);

  switch (bsin.getFid())
  {
    case (ID_FIRMWARE):
      firmsaver->Program(bsin.come->msg, len);

      if (len == 0)
      {
        firm_inst.load = true;
        firm_inst.accept = true;
        firm_inst.res = true;
        LoadTim(sessgsm_to, 1000);
      }

      break;

    default:
      break;
  }

  if (len == 0)
    bsin.ResetAll();

  gsm0.SendBin((uint8_t*)(bsin.from), 4);
  return 0;
}
/* ------------------------------------------------------------------------- *

 * ------------------------------------------------------------------------- */
int32_t GTftpRRQParse(uint16_t len)
{
  int32_t fsize = -1, ret0;
  bsin.headUp();
  bsin.Options(0x0401);
  bsin.setFid();

  switch (bsin.getFid())
  {
    case ID_GET_FILENOTES:
      fsize = (FileLink())->RefreshTrekList();
      break;

    case ID_GET_TRACK:
      ret0 = (FileLink())->GetListIndex(bsin.Options());

      if (ret0 >= 0)
        fsize = (FileLink())->GetTrekSize(bsin.NeedTreck(ret0));
      else
      {
        fsize = 0;
        bsin.headError(6);
        bsin.ResetAll();
      }

      break;

    case ID_GET_INFO:
      sprintf(testinfostring, INFO_STRING_MASK,
              imei_str, MAJOR_VERSION, MINOR_VERSION, PATCH_VERSION, memconf.ID);
      fsize = strlen(testinfostring);
      break;

    case ID_GET_ECHO:
      fsize = 0;
      bsin.ResetAll();
      break;

    default:
      bsin.headError(5);
      fsize = 0;
      break;
  }

  DBG_2Gsm("RRQ> Size:%d\n", fsize);
  bsin.FSize((uint32_t)(fsize));
  gsm0.SendBin((uint8_t*)(bsin.from), 6 + 4);
  bsin.bchief.Anew();
  return 0;
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
int32_t GTftpWRQParse(uint16_t len)
{
  len -= 4;

  if (len < 6) return -1;

  bsin.ResetAll();

  if (bsin.FSize() != 0)
  {
    /* correct file size waiting */
    bsin.setFid();
    firmsaver->Erase();
  }

  bsin.headUp();
  gsm0.SendBin((uint8_t*)(bsin.from), 4);
  DBG_2Gsm("WRQ> Size:%d\n", bsin.FSize());
  return 0;
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */


void GTftp2Process(uint8_t* msg, uint16_t len)
{
  bsin.come = (GTftp2_t*)msg;
  bsin.from = (GTftp2_t*)GSM_TX_Buff;

  if (len > 3)
  {
    DBG_2Gsm("ftp <- opc=%d, id=%04x. len=%d\n", bsin.come->opc, bsin.come->blockid,
             len);

    if (bsin.come->opc == OPC_RRQ)
      GTftpRRQParse(len);
    else if (bsin.come->opc == OPC_ACK)
      GTftpACKParse(len);
    else if (bsin.come->opc == OPC_WRQ)
      GTftpWRQParse(len);
    else if (bsin.come->opc == OPC_DATA)
      GTftpDATAParse((int32_t)len);
    else { }
  }

  GTftpSend(0);
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */
void JConfInit()
{
  JConfUpload((uint8_t*)&memconf, memconf.Lenght());

  if (!memconf.JCIsSign())
  {
    memconf.JCDefault();
    JConfSave((uint8_t*)&memconf, memconf.Lenght());
  }
}
/* ------------------------------------------------------------------------- */
uint32_t JConfNetInit(char* s, char* out)
{
  /* ??? why need ret */
  volatile int32_t ret;
  uint32_t preamb = __REV(*(uint32_t*)s);
  uint32_t typepreamb;
  /* valid value */
  typepreamb = ((preamb & 0x0000FF00) >> 8) - 0x30;
  preamb = (preamb & 0x000000FF) - 0x30;

  if (preamb > 5)
  {
    /* error statement */
    strcpy(out, "oshibka: nevernye parametry\n");
    return (strlen(out));
  }

  if (preamb != 0)
  {
    if (typepreamb == 0)
      ret = memconf.IP[preamb - 1].Update(s + 4);
    else if (typepreamb == 1)
      ret = memconf.IP[preamb - 1].UpdateTim(s + 4);
  }
  else
    preamb = memconf.SocketBits(s + 4);

  sprintf(out, "%d: ", preamb);
  memconf.IP[preamb - 1].Print(out + strlen(out));
  JConfSocketUpdate();
  JConfSave((uint8_t*)&memconf, memconf.Lenght());
  return strlen(out);
}
/* ------------------------------------------------------------------------- */
int32_t JConfSocketUpdate()
{
  currgprs = (memconf.sockbit.Socket() != 0) ?
             (&(memconf.IP[memconf.sockbit.Socket() - 1])) : ((TcpInstance_c*)&defgprs);
  currgprs->PrintIP(ssrv[0]);
  currgprs->PrintPort(ssrv[1]);
  TOSession(1);
  return 0;
}
/* ------------------------------------------------------------------------- */
void osDelay(uint16_t tim)
{
  os_dly_wait(tim);
  gsm0.Flush();
}

/* ------------------------------------------------------------------------- *
 *
 * ------------------------------------------------------------------------- */
uint8_t MainSmsParsing(char* inSms)
{
  uint32_t preamb;
  DBG_Gsm("%s\n", inSms);
  DBG_Gsm("%x\n", *(uint32_t*)(inSms));
  preamb = swapp::Word(*(uint32_t*)(inSms));
  bool is_answer = true;

  switch (*(uint32_t*)(inSms))
  {
    case (0x31303023):
      prdat.len = PrintYandexLink((char*)GSM_TX_Buff, 256);
      break;

    case (0x32303023):
      prdat.len = PrintTextLink((char*)GSM_TX_Buff, 256);
      break;

    case (0x33303023):
      prdat.len = PrintGoogleLink((char*)GSM_TX_Buff, 256);
      break;

    default:
      is_answer = false;
      break;
  }

  if ((preamb & 0xFF000000) == 0x2A000000)
  {
    // '*' - first symbol
    preamb &= ~0xFF000000;
    preamb |= 0x23000000;
    is_answer = true;
  }

  switch (preamb & 0xFFFF0000)
  {
    case (0x23310000):
      /* GPRS params */
      prdat.len = JConfNetInit(inSms, (char*)GSM_TX_Buff);
      break;
  } // swirch;

  if (is_answer)
    GSM_Send_SMS(Inc_Phone_In, prdat.len, GSM_SMS_FORMAT_7BIT);

  DBG_Gsm("%s\n", GSM_TX_Buff);
  return 0;
}



/* ------------------------------------------------------------------------- */
int32_t m66NetStat(char* buf, int32_t len)
{
  if (memcmp(buf, "IP INI", 6) == 0)
    return 2;
  else if ((memcmp(buf, "IP START", 6) == 0) ||
           (memcmp(buf, "IP CLOSE", 6) == 0))
    return 1;

  return 0;
}


/* ------------------------------------------------------------------------- */
uint16_t m66Syncro(uint16_t numtry, uint16_t delay)
{
  do
  {
    os_dly_wait(delay);
    DBG_Gsm("[qm]:AT echo: ");
    gsm0.StrCmd(atcmd::ECHO);

    if (GsmGetAck(200, atcmd::ACK_OK, 0) > 0)
      return numtry;
  }
  while (numtry--);

  return 0;
}


/* ------------------------------------------------------------------------- */
uint16_t m66SimCheck(uint32_t delay)
{
  TOCommon(delay);

  do
  {
    os_dly_wait(500);
    DBG_Gsm("\n[at]:SIM check <>: ");
    gsm0.StrCmd("AT+CPIN?\r\n");

    if (GsmGetAck(1 * TIMER_FREQ, AT_COMMAND_CPIN_ACK, 0) > 0)
      /* if correct answer SIM ready ->break from "while" loop */
      return 1;
  }
  while (TOCommon());

  return 0;
}


/* ------------------------------------------------------------------------- */
void m66FixIpr()
{
  gsm0.StrCmd("AT+IPR?\r\n");
  GsmGetAck(300, "+IPR: ", 0);
  str0::str0_t* fs = gsm0.Str();
  fs = str0::ToSym(fs, ' ', 1);
  int32_t ret = str0::Atoi(fs);

  if (ret != 115200)
  {
    gsm0.StrCmd("AT+IPR=115200&W\r\n");
    GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
  }
}


/* ------------------------------------------------------------------------- */
void m66EchoOff()
{
  DBG_Gsm("[at]:AT Echo off> ");
  gsm0.StrCmd(AT_ECHO_MODE_OFF);
  GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
}


/* ------------------------------------------------------------------------- */
void m66GetImei()
{
  DBG_Gsm("[at]AT IMEI: ");
  gsm0.StrCmd("AT+GSN\r\n");

  if (GsmGetAck(300, 0, 0) > 10)
    strcpy(imei_str, gsm0.Str());
}


/* ------------------------------------------------------------------------- */
void m66CommonConf()
{

//	DBG_Gsm("[at]AT IMEI: ");
//	gsm0.StrCmd("AT+GSN\r\n");
//	GsmGetAck(300, 0, 0);
  DBG_Gsm("[at]AT DTR MODE: ");
  gsm0.StrCmd("AT&D1\r\n");
  GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
  DBG_Gsm("[at]AT SMS MODE: ");
  gsm0.StrCmd("AT+CMGF=0\r\n");  // To PDU mode
  GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
  DBG_Gsm("[at]AT TRANSPAR MODE: ");
  gsm0.StrCmd("AT+QIMODE=1\r\n");
  GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
  DBG_Gsm("[at]AT DTR TRANSPAR CONF: ");
  gsm0.StrCmd("AT+QITCFG=3,2,768,1\r\n");
  GsmGetAck(300, AT_COMMAND_OK_ACK, 0);
  m66GetImei();
//  gsm0.StrCmd("AT+QNITZ=1\r\n");
//  GsmGetAck(300, "+QNITZ: ", 0);
//  gsm0.StrCmd("AT+CTZU=1\r\n");
//  GsmGetAck(300, "+CTZU: ", 0);
}


/* ------------------------------------------------------------------------- */
int32_t m66Clock()
{
  gsm0.StrCmd(AT_CLOCK_GET);
  return GsmGetAck(300, AT_CLOCK_ANSWER, 0);
}


/* ------------------------------------------------------------------------- */
int32_t m66RegisterCheck()
{
  /* CREG answer, scan reg value */
  DBG_Gsm("[at]:[idle] Get reg> ");
  gsm0.StrCmd(AT_REG_STATE_GET);

  if (GsmGetAck(300, AT_REG_STATE_ANSWER, 0) > 0)
    gsm0.SetSig(1);

  DBG_Gsm("[at]:[idle] CSQ> ");
  gsm0.StrCmd(AT_SIGNAL_QUALITY_GET);

  if (GsmGetAck(300, AT_SIGNAL_QUALITY_ANSWER, 0) > 0)
    gsm0.SetSig(0);

  gsm0.StrCmd("AT+CGREG?\r\n");
  GsmGetAck(300, "+CGREG: ", 0);
  return 0;
}


/* ------------------------------------------------------------------------- */
int32_t m66CheckSession()
{
  int32_t retval;
  eLedState = eledNoEcho;

  if (m66Clock() <= 0)
  {
    DBG_2Gsm("[conn]warn time no answer\n");
    return 1;
  }

  eLedState = eLedConn;

  /* if session timeout --> exit */
  if (!TOSession())
    return 1;

//	gsm0.StrCmd(atcmd::SMS_GET);
//	GsmGetAck(1 * TIMER_FREQ, AT_SMS_GET_ANSWER, AT_COMMAND_OK_ACK);

  if (GsmReceiveSMS(Inc_Phone_In) != 0)
  {
    if ((MainSmsParsing((char*)GSM_RX_Buff)) == 1)
    {
      DBG_2Gsm("[conn]warning sms detect\n");
      return 1;
    }
  }

  DBG_Gsm("[conn]resume session> ");
  gsm0.StrCmd(AT_GPRS_RESTORE_SOCKET); // return to data mode
  retval = GsmGetAck(1 * TIMER_FREQ, "CONNECT", "NO CARR");

  if (!(retval > 0))
  {
    DBG_2Gsm("[conn]warning resume connection state : %d\n", retval);
    return 1;
  }

  return 0;
}


/* ------------------------------------------------------------------------- */
uint8_t m66ConnectionClose()
{
  DBG_Gsm("[at]:[conn] close session> ");
  gsm0.StrCmd("AT+QICLOSE\r\n");
  /* wait 5 sec for correct answer */
  GsmGetAck(5000, "CLOSE OK", "ERROR");
  gsm0.StrCmd("AT+QISTATE\r\n");
  GsmGetAck(300, "STATE:", "ERROR");
  /* set session timer to pause */
  return 1;
}


/*
* Base tcp udp connection process
* at first is getting current service status
* next action depends on current status
*
* @param - return. Return may be OK, FAIL or FATAL ERROR (deact non answer)
* it mean that module must be reload
* */
uint8_t m66ConnectionStart()
{
  int32_t retval;
  DBG_Gsm("[conn] check state\n");
  gsm0.StrCmd("AT+QISTATE\r\n");
  retval = GsmGetAck(300, "STATE:", "ERROR");

  if (retval > 0)
    retval = m66NetStat((char*)str0::ToSym(gsm0.Str() , ' ', 1), retval);

  if (retval == 2) goto __ACT;
  else if (retval == 1) goto __CONN;

  DBG_Gsm("[conn]deactivation \n");
  gsm0.StrCmd("AT+QIDEACT\r\n");
  retval = GsmGetAck(30 * TIMER_FREQ, "DEACT OK", "ERROR");

  if (retval <= 0)
  {
    /* fail deactivation FATAL ERROR */
    DBG_Gsm("[conn] deactivation error\n");
  }

__ACT:
  DBG_Gsm("[conn] start TCP task res =");
  gsm0.StrCmd("AT+QIREGAPP\r\n");
  retval = GsmGetAck(300, AT_COMMAND_OK_ACK, "ERROR");
  DBG_Gsm("%d\n", retval);
  DBG_Gsm("[conn] Activate context res =");
  gsm0.StrCmd("AT+QIACT\r\n");
  retval = GsmGetAck(30 * TIMER_FREQ, AT_COMMAND_OK_ACK, "ERROR");
  DBG_Gsm("%d\n", retval);
  gsm0.StrCmd("AT+QILOCIP\r\n");
  retval = GsmGetAck(300, 0, "ERROR");
__CONN:
  DBG_Gsm("[conn] Start connect\n");
  eLedState = eLedConn;
  gsm0.CipStr(ssrv[0], ssrv[1]);

//  GsmGetAck(15 * TIMER_FREQ, "CONNECT", "CONNECT FAIL");
  if (GsmGetAck(15 * TIMER_FREQ, AT_GPRS_CONNECT_OK_ANSWER,
                AT_CONNECT_FAIL_ACK) <= 0)
    return 0;

  return 1;
}


/* ------------------------------------------------------------------------- */
void m66DCDHandle()
{
  if (dcd.Input() != dcd_state)
  {
    dcd_state = (dcd.Input());
    DBG_Gsm("[DCD]Changed = %d\n", (int)dcd_state);
  }
}


/* ------------------------------------------------------------------------- *
 * ------------------------------------------------------------------------- *
 *                            TASK GSM START
 * ------------------------------------------------------------------------- *
 * ------------------------------------------------------------------------- */
void tskGsm(void*)
{
  memset((void*) & (dateTime), 0, sizeof(dateTime));
  os_dly_wait(500);
  DBG_Gsm("*<* Gsm task start complete *>*\n\n");
  g_GsmMainState = eG_Start;
  JConfInit();

  /*------------------------------------------*/
  while (1)     /* deadloop for GSM task */
  {
    m66DCDHandle();
    os_tsk_pass(); /* main task pass */

    switch (g_GsmMainState)
    {
      /* -------------------------------------------------------- */
      case (eG_Wait):
      {
        g_GsmMainState = eG_Start; // *---> exit sleep
        break;
      }

      /* -++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
      case (eG_Start):
      {
        eLedState = eLedIdle;
        /* start modem init */
        GsmSwitchOn();

        if (!(m66Syncro(15, 400)))
        {
          g_GsmMainState = eG_Start;
          break;
        }

        m66EchoOff();
        m66FixIpr();
        m66CommonConf();
        eLedState = eLedNoSim;

        if (!m66SimCheck(3600 * 1000))
        {
          g_GsmMainState = eG_Start;
          break;
        }

        /* all OK state to   */
        g_GsmMainState = eG_Init;
        JConfSocketUpdate();
        break;
      }

      /* -++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
      case (eG_Init):
      {
//				LoadSecTim(gsm_restart_to, NET_RESTART_TO);
        LoadTim(incgsm_to, 1000);
        eLedState = eLedNoReg;
        time_register_wait = (time_register_wait < 360) ?
                             (time_register_wait + (NET_REG_SEC_TIMEOUT * 2)) : (360);
        LoadSecTim(gsm_register_to, time_register_wait);
        g_GsmMainState = (firm_inst.res) ? eG_HardDie : eG_Idle;
        break;
      }

      /* -++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
      case (eG_Idle):
      {
        os_tsk_pass();

        if (!TOSession() && gsm0.RegOk())
        {
          g_GsmMainState = eG_TryConnect;
          break;
        }

        /* ----------------- BIG block SMS and Net state ------------------- */
        if (!(GetTim(incgsm_to)))
        {
          DBG_2Gsm("\n[shedul]:connect wait...<%d>\n", TOSession());
          DBG_Gsm("[at]:[idle] time> ");
          LoadTim(incgsm_to, 9000);

          if (m66Clock() <= 0)
          {
            g_GsmMainState = eG_Start;
            break;
          }

          eLedState = eledNoEcho;
          /* CREG answer, scan reg value */
          m66RegisterCheck();
          eLedState = eLedNoReg;

          if (gsm0.RegOk())
          {
            eLedState = eLedReg;
            LoadSecTim(gsm_register_to, NET_REG_SEC_TIMEOUT);

            if (GsmReceiveSMS(Inc_Phone_In) > 1)
              MainSmsParsing((char*)GSM_RX_Buff);
          }

          /* end check net state block check incoming SMS */

          if (true)
          {
//            strcpy((char*)GSM_RX_Buff, "#001");
//            MainSmsParsing((char*)GSM_RX_Buff);
//            strcpy((char*)GSM_RX_Buff, "#002");
//            MainSmsParsing((char*)GSM_RX_Buff);
//            strcpy((char*)GSM_RX_Buff, "#003");
//            MainSmsParsing((char*)GSM_RX_Buff);
//            strcpy((char*)GSM_RX_Buff, "#105#64.48.155.8825#20010");
//            MainSmsParsing((char*)GSM_RX_Buff);
//            strcpy((char*)GSM_RX_Buff, "#111#012#5#3");
//            MainSmsParsing((char*)GSM_RX_Buff);
//
//						strcpy((char*)GSM_RX_Buff, "?100");
//            MainSmsParsing((char*)GSM_RX_Buff);
//												strcpy((char*)GSM_RX_Buff, "?102");
//            MainSmsParsing((char*)GSM_RX_Buff);
//												strcpy((char*)GSM_RX_Buff, "?106");
//            MainSmsParsing((char*)GSM_RX_Buff);
//												strcpy((char*)GSM_RX_Buff, "?101");
//            MainSmsParsing((char*)GSM_RX_Buff);
          }
        }

//				/* ------------- BIG block SMS and Net state END --------------------- */
//				if ((!GetTim(gsm_register_to)) || GetTim(gsm_restart_to) == 0)
//				{
//					DBG_Gsm("RegSecTimer: %d | NetRestertSecTimer: %d\n",
//					        GetTim(gsm_register_to), GetTim(gsm_restart_to));
//					g_GsmMainState = eG_Start;
//				}

        /* ------------- BIG block SMS and Net state END --------------------- */
        if (GetTim(gsm_register_to) == 0)
        {
          DBG_Gsm("[gsm] register time out\n");
          g_GsmMainState = eG_Start;
        }

        break;
      }

      /* -++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
      case (eG_TryConnect):
      {
        if (currgprs->TcpValid() == false)
        {
          DBG_Gsm("[gsm] TConn: warn> not valid\n");
          TOSession(currgprs->reconnto);
          g_GsmMainState = eG_Idle;
          break;
        }

        /* try connect */
        DBG_Gsm("[gsm] TConn:OK connectioin start:%s %s\n", ssrv[0], ssrv[1]);
        TOSession(currgprs->reconnto);

        if (m66ConnectionStart() == 0)
        {
          /* decrease restart timer  */
          /* ??? 09.01.2016 may be no needness for restart in case
           * fail connection */
//					uint32_t temptim = GetTim(gsm_restart_to);
//					if (temptim >= (NET_RESTART_TO / 10))
//						LoadSecTim(gsm_restart_to, temptim - (NET_RESTART_TO / 10));
//					else
//						LoadSecTim(gsm_restart_to, 0);
          g_GsmMainState = eG_Disconnect;
          break; // break from case.
        }

        TOSession(currgprs->bigto);
        /* this timer using for silence timeout */
        LoadTim(incgsm_to, 1000 * 20); /* break time out */
        TOSilence(currgprs->silentto); /* global stop timeout */
        g_GsmMainState = eG_ConnIdle;
        /* ??? need reset bsin state */
        bsin.ResetAll();
        break;
      }

      /* -++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
      case (eG_ConnIdle):
      {
        os_tsk_pass();

        if (dcd_state)
        {
          g_GsmMainState = eG_Disconnect;
          break;
        }

        if (!GetTim(incgsm_to))
        {
//					DBG_2Gsm("[conn]Silence: %ds. Global:%ds\n", TOSilence() / 1000, TOSession() / 1000);
          DBG_2Gsm("\r\n --- <ALIVE> Silence: %ds. Global:%ds ---\r\n",
                   TOSilence() / 1000, TOSession() / 1000);
          LoadTim(incgsm_to, GPRS_ACTIVE_TIMEOUT);
          m66BreakSession();

          if (!TOSilence() || m66CheckSession())
          {
            g_GsmMainState = eG_Disconnect;
            break;
          }
        }

        int32_t ret;
        uint16_t rec_len = 0;
        ret = gsm0.ReceiveBin(GSM_RX_Buff, rec_len);

        if (ret > 0)
        {
          if (GetTim(incgsm_to) < 5000)
            LoadSecTim(incgsm_to, 5);

          TOSilence(currgprs->silentto);
        }

        GTftp2Process(GSM_RX_Buff, rec_len);
        break;
      }

      /* -+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++- */
      case (eG_Disconnect):
      {
        DBG_2Gsm("[conn]:DISCONNECT\n");
        m66ConnectionClose();
        TOSession(currgprs->reconnto);
        g_GsmMainState = (eG_Init);
        break;
      }

      /* -+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++- */
      case (eG_HardDie):
      {
        if (firm_inst.load && firm_inst.accept)
        {
          DBG_Common("\n=[SYS]HELLO ARMAGEDON!!!\n");
          os_dly_wait(1);
          __disable_irq();
          SYSTICKDISABLE;
          KillFlash();
        }

        HARDRESRET;
      }

      default:
        break;
    } // switch
  }//while (1)  dead loop
} // task


void Start_GsmThread()
{
  xTaskCreate(tskGsm, "tskGsm", kLowStackSz, (void*)NULL, kPrio_IDLE, NULL);
}


void tskGsm(void*)
{
  while (1)
  {
    __nop();
    osPass();
  }
}

